# LessonEleven
1. Как получить ссылку на текущий поток ?
``` Thread.currentThread() ```
2. Зачем нужно ключевое слово synchronized ? На что его можно вещать(поле, метод, класс, конструктор..)?<br />
Ключевое слово synchronized используется для синхронизации потоков в Java. Вешаеться на метод либо блок кода(можно синхронизироывть по какому-то объекту).
Оно означает, что определённый кусок кода может выполняться только одним потоком одновременно.
3. Захват какого монитора происходит при входе в synchronized метод/статик метод/блок ?
Метод - синхронизируется по объекту this, то есть по текущему объекту.;
Статик метод - ссылка на объект Class<?> ;
Блок - синхронизируется по объекту, переданному в аргумент.
5. Зачем нужно ключевое слово volatile ? На что его можно вещать(поле, метод, класс, конструктор..) ?
Можно вешать на поля класса. Переменная всегда будет атомарно читаться/записываться и Java-машина не будет помещать ее в кэш.
Оно гарантирует, что при последующем считывании поля будет видно значение, которое было задано самой последней записью.
7. Что делает метод Object#wait, Object#notify, Object#notifyAll
Object#wait - используется, чтобы заставить поток перейти в состояние WAITING или TIMED_WAITING (если передано значение тайм-аута)
Object#notify - пробуждает произвольный поток, ожидающий на мониторе.
Object#notifyAll -  пробуждает все потоки, ожидающие на мониторе.
9. Что за исключение IllegalMonitorStateException ?
Исключение выдается, чтобы указать, что поток пытался подождать или уведомить другие потоки, ожидающие на этом мониторе, не владея им.
Это исключение можно получить, если вызвать один из методов wait(), notify(), или notifyAll() класса Object за пределами синхронизированного блока.
11. Что делает метод Thread#join ?
Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.
12. Что делает метод Thread#interrupt ? 
Вызов этого метода устанавливает у потока статус, что он прерван. При этом сам вызов этого метода НЕ завершает поток.

Реализовать ThreadPool
```
public interface ThreadPool {
  void start(); // запускает потоки. Потоки бездействуют, до тех пор пока не появится новое задание в очереди (см. execute)

  void execute(Runnable runnable); // складывает это задание в очередь. Освободившийся поток должен выполнить это задание.
                                   // Каждое задание должны быть выполнено ровно 1 раз
   }
```

Сделать 2 реализации ThreadPool
1) FixedThreadPool - Количество потоков задается в конструкторе и не меняется.
2) ScalableThreadPool в конструкторе задается минимальное и максимальное(int min, int max) число потоков,
количество запущенных потоков может быть увеличено от минимального к максимальному, если при добавлении нового задания в очередь нет свободного потока для исполнения этого задания. При отсутствии задания в очереди, количество потоков опять должно быть уменьшено до значения min
